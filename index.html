<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cycling Power Estimator (1s, Medians, Session Avg)</title>
    <style>
        /* CSS remains largely the same */
        body { font-family: sans-serif; margin: 10px; background-color: #f0f0f0; color: #333; line-height: 1.6; }
        .container { max-width: 600px; margin: 0 auto; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1, h2 { color: #0056b3; text-align: center; }
        p { margin: 8px 0; }
        strong { color: #007bff; }
        .coordinates, .power-output, .median-output, .session-summary-output { font-family: monospace; font-size: 1.1em; }
        button { display: block; width: 100%; padding: 12px 15px; margin-top: 15px; background-color: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1em; }
        button:hover { background-color: #218838; }
        button.stop { background-color: #dc3545; }
        button.stop:hover { background-color: #c82333; }
        #permissionStatus { font-style: italic; margin-bottom: 10px; text-align: center; }
        .input-group { margin-bottom: 12px; }
        .input-group label { display: block; margin-bottom: 5px; font-weight: bold; }
        .input-group input { width: calc(100% - 22px); padding: 10px; border: 1px solid #ccc; border-radius: 4px; }
        hr { border: 0; height: 1px; background: #ddd; margin: 20px 0; }
        #sessionSummary { margin-top: 20px; padding-top: 15px; border-top: 2px solid #0056b3;}
    </style>
</head>
<body>
    <div class="container">
        <h1>Cycling Power Estimator (1s, Medians, Session Avg)</h1>
        <div id="permissionStatus">Requesting permissions...</div>

        <h2>Configuration</h2>
        <div class="input-group">
            <label for="totalMass">Total Mass (rider+bike, kg):</label>
            <input type="number" id="totalMass" value="80">
        </div>
        <div class="input-group">
            <label for="dragCoefficient">Drag Coefficient (Cd):</label>
            <input type="number" id="dragCoefficient" step="0.01" value="0.7">
        </div>
        <div class="input-group">
            <label for="frontalArea">Frontal Area (A, m²):</label>
            <input type="number" id="frontalArea" step="0.01" value="0.5">
        </div>
        <div class="input-group">
            <label for="rollingResistance">Rolling Resistance Coeff (Crr):</label>
            <input type="number" id="rollingResistance" step="0.001" value="0.005">
        </div>
        <div class="input-group">
            <label for="airDensity">Air Density (kg/m³):</label>
            <input type="number" id="airDensity" step="0.01" value="1.1">
        </div>
        <div class="input-group">
            <label for="accelFilterAlpha">Accel. Filter Alpha (0-1, smaller=smoother):</label>
            <input type="number" id="accelFilterAlpha" step="0.01" min="0.01" max="0.99" value="0.2">
        </div>

        <button id="startTrackingButton">Start Tracking & Estimating Power</button>

        <hr>
        <h2>Live Data (per 1-second window)</h2>
        <p><strong>Status:</strong> <span id="status">Idle</span></p>
        <p class="power-output"><strong>Estimated Power:</strong> <span id="powerOutput">0</span> W</p>
        <p class="coordinates">Win. Disp. X: <span id="imuDispX">0.00</span>m, Y: <span id="imuDispY">0.00</span>m, Z: <span id="imuDispZ">0.00</span>m</p>
        <p class="coordinates">Win. Final Vel. (H): <span id="winFinalVelH">0.00</span> m/s (<span id="winFinalVelHKmh">0.0</span> km/h)</p>
        <p>Window Duration: <span id="windowDuration">0.00</span>s</p>
        <hr>
        <h2>Medians (Top 5 of last 10 samples)</h2>
        <p class="median-output"><strong>Median Power:</strong> <span id="medianPowerOutput">0</span> W</p>
        <p class="median-output"><strong>Median Velocity (H):</strong> <span id="medianVelocityOutput">0.00</span> m/s (<span id="medianVelocityOutputKmh">0.0</span> km/h)</p>

        <div id="sessionSummary" style="display: none;">
            <hr>
            <h2>Session Summary</h2>
            <p class="session-summary-output"><strong>Avg. of Median Power:</strong> <span id="avgMedianPower">0</span> W</p>
            <p class="session-summary-output"><strong>Avg. of Median Velocity (H):</strong> <span id="avgMedianVelocity">0.00</span> m/s (<span id="avgMedianVelocityKmh">0.0</span> km/h)</p>
        </div>
    </div>

    <script>
        // --- UI Elements ---
        const statusEl = document.getElementById('status');
        const powerOutputEl = document.getElementById('powerOutput');
        const imuDispXEl = document.getElementById('imuDispX');
        const imuDispYEl = document.getElementById('imuDispY');
        const imuDispZEl = document.getElementById('imuDispZ');
        const winFinalVelHEl = document.getElementById('winFinalVelH');
        const winFinalVelHKmhEl = document.getElementById('winFinalVelHKmh');
        const windowDurationEl = document.getElementById('windowDuration');
        const medianPowerOutputEl = document.getElementById('medianPowerOutput');
        const medianVelocityOutputEl = document.getElementById('medianVelocityOutput');
        const medianVelocityOutputKmhEl = document.getElementById('medianVelocityOutputKmh');
        const sessionSummaryEl = document.getElementById('sessionSummary');
        const avgMedianPowerEl = document.getElementById('avgMedianPower');
        const avgMedianVelocityEl = document.getElementById('avgMedianVelocity');
        const avgMedianVelocityKmhEl = document.getElementById('avgMedianVelocityKmh');
        const startTrackingButton = document.getElementById('startTrackingButton');
        const permissionStatusEl = document.getElementById('permissionStatus');

        // --- Input Elements ---
        const totalMassInput = document.getElementById('totalMass');
        const dragCoefficientInput = document.getElementById('dragCoefficient');
        const frontalAreaInput = document.getElementById('frontalArea');
        const rollingResistanceInput = document.getElementById('rollingResistance');
        const airDensityInput = document.getElementById('airDensity');
        const accelFilterAlphaInput = document.getElementById('accelFilterAlpha');

        // --- State Variables ---
        let linearAccelerationSensor = null;
        let absoluteOrientationSensor = null;

        let imuRawAcceleration = { x: 0, y: 0, z: 0 };
        let imuOrientationQuaternion = [0, 0, 0, 1];
        let filteredWorldAcceleration = { x: 0, y: 0, z: 0 };
        let imuVelocity_window = { x: 0, y: 0, z: 0 };
        let imuPositionOffset_window = { x: 0, y: 0, z: 0 };

        let lastTimestamp_IMU_Processing = null;
        let isTracking = false;
        const GRAVITY_ACCEL = 9.80665;
        let ACCEL_FILTER_ALPHA = 0.2;

        let oneSecondCycleTimer = null; // Renamed from twoSecondCycleTimer
        let lastOneSecondCycleTimestamp = 0; // Renamed
        let userPowerParams = {};

        // History for median calculation
        let powerWindowHistory = []; // Stores raw power values from each 1s window
        let velocityWindowHistory = []; // Stores final horizontal velocity (m/s) from each 1s window
        const MAX_WINDOW_HISTORY_LENGTH = 10;

        // History for session averages of medians
        let sessionMedianPowerSamples = [];
        let sessionMedianVelocitySamples = []; // Stores median velocity in m/s


        function mpsToKmh(mps) {
            return mps * 3.6;
        }

        function rotateVectorByQuaternion(vec, quat) {
            const [qx, qy, qz, qw] = quat;
            const { x, y, z } = vec;
            const tx = 2 * (qy * z - qz * y);
            const ty = 2 * (qz * x - qx * z);
            const tz = 2 * (qx * y - qy * x);
            const rotatedX = x + qw * tx + (qy * tz - qz * ty);
            const rotatedY = y + qw * ty + (qz * tx - qx * tz);
            const rotatedZ = z + qw * tz + (qx * ty - qy * tx);
            return { x: rotatedX, y: rotatedY, z: rotatedZ };
        }

        function processIMUData() {
            if (!isTracking || lastTimestamp_IMU_Processing === null) return;
            const now = performance.now();
            const deltaTimeIMU = (now - lastTimestamp_IMU_Processing) / 1000.0;
            lastTimestamp_IMU_Processing = now;

            if (deltaTimeIMU <= 0 || deltaTimeIMU > 0.5) {
                 console.warn(`Anomalous deltaTimeIMU: ${deltaTimeIMU.toFixed(4)}s. Skipping.`);
                 return;
            }

            const currentWorldAccelSample = rotateVectorByQuaternion(imuRawAcceleration, imuOrientationQuaternion);
            filteredWorldAcceleration.x = ACCEL_FILTER_ALPHA * currentWorldAccelSample.x + (1 - ACCEL_FILTER_ALPHA) * filteredWorldAcceleration.x;
            filteredWorldAcceleration.y = ACCEL_FILTER_ALPHA * currentWorldAccelSample.y + (1 - ACCEL_FILTER_ALPHA) * filteredWorldAcceleration.y;
            filteredWorldAcceleration.z = ACCEL_FILTER_ALPHA * currentWorldAccelSample.z + (1 - ACCEL_FILTER_ALPHA) * filteredWorldAcceleration.z;

            const v0x = imuVelocity_window.x;
            const v0y = imuVelocity_window.y;
            const v0z = imuVelocity_window.z;
            imuVelocity_window.x += filteredWorldAcceleration.x * deltaTimeIMU;
            imuVelocity_window.y += filteredWorldAcceleration.y * deltaTimeIMU;
            imuVelocity_window.z += filteredWorldAcceleration.z * deltaTimeIMU;
            imuPositionOffset_window.x += (v0x + imuVelocity_window.x) / 2 * deltaTimeIMU;
            imuPositionOffset_window.y += (v0y + imuVelocity_window.y) / 2 * deltaTimeIMU;
            imuPositionOffset_window.z += (v0z + imuVelocity_window.z) / 2 * deltaTimeIMU;
        }

        function calculateCyclingPower(params) {
            const { displacement, finalVelocity, deltaTimeWindow, userConfig } = params;
            if (deltaTimeWindow < 0.05) { // Adjusted guard for 1s window
                return {power: 0, finalVelocityHorizontal: 0};
            }
            const dx = displacement.x; const dy = displacement.y; const dz = displacement.z;
            const distanceHorizontal = Math.sqrt(dx * dx + dy * dy);
            const finalVelocityHorizontal = Math.sqrt(finalVelocity.x * finalVelocity.x + finalVelocity.y * finalVelocity.y);
            const initialVelocityHorizontal = 0;
            const workGravity = userConfig.totalMass * GRAVITY_ACCEL * dz;
            const avgVelocityHorizontalForDrag = finalVelocityHorizontal / 2;
            const forceDrag = 0.5 * userConfig.airDensity * avgVelocityHorizontalForDrag * avgVelocityHorizontalForDrag * userConfig.dragCoefficient * userConfig.frontalArea;
            const workDrag = forceDrag * distanceHorizontal;
            const forceRolling = userConfig.rollingResistanceCoefficient * userConfig.totalMass * GRAVITY_ACCEL;
            const workRolling = forceRolling * distanceHorizontal;
            const finalVelocityMagnitude = Math.sqrt(finalVelocity.x**2 + finalVelocity.y**2 + finalVelocity.z**2);
            const workKinetic = 0.5 * userConfig.totalMass * (finalVelocityMagnitude * finalVelocityMagnitude);
            const totalWork = workGravity + workDrag + workRolling + workKinetic;
            let power = totalWork / deltaTimeWindow;
            return {power: power > 0 ? power : 0, finalVelocityHorizontal: finalVelocityHorizontal};
        }

        function calculateMedian(arr) {
            if (!arr || arr.length === 0) return 0;
            const sortedArr = [...arr].sort((a, b) => a - b);
            const mid = Math.floor(sortedArr.length / 2);
            if (sortedArr.length % 2 === 0) {
                if (sortedArr.length < 2) return sortedArr[0] || 0;
                return (sortedArr[mid - 1] + sortedArr[mid]) / 2;
            } else {
                return sortedArr[mid];
            }
        }

        function calculateMedianOfTopN(arr, totalSamplesToConsider, topN) {
            if (!arr || arr.length === 0) return 0;
            const consideredSamples = arr.length > totalSamplesToConsider ? arr.slice(-totalSamplesToConsider) : [...arr];
            if (consideredSamples.length === 0) return 0; // handle empty after slice
            if (consideredSamples.length < topN) {
                return calculateMedian(consideredSamples);
            }
            const sortedArrDesc = [...consideredSamples].sort((a, b) => b - a);
            const topNValues = sortedArrDesc.slice(0, topN);
            return calculateMedian(topNValues);
        }

        function calculateAverage(arr) {
            if (!arr || arr.length === 0) return 0;
            const sum = arr.reduce((acc, val) => acc + val, 0);
            return sum / arr.length;
        }

        function updateUIDisplayCycleEnd(displacement, finalVelocity, duration, currentPowerData, medianPower, medianVelocityMps) {
            imuDispXEl.textContent = displacement.x.toFixed(2);
            imuDispYEl.textContent = displacement.y.toFixed(2);
            imuDispZEl.textContent = displacement.z.toFixed(2);
            imuVelXEl.textContent = finalVelocity.x.toFixed(2);
            imuVelYEl.textContent = finalVelocity.y.toFixed(2);
            imuVelZEl.textContent = finalVelocity.z.toFixed(2);
            winFinalVelHEl.textContent = currentPowerData.finalVelocityHorizontal.toFixed(2);
            winFinalVelHKmhEl.textContent = mpsToKmh(currentPowerData.finalVelocityHorizontal).toFixed(1);
            windowDurationEl.textContent = duration.toFixed(2);
            powerOutputEl.textContent = currentPowerData.power.toFixed(0);
            medianPowerOutputEl.textContent = medianPower.toFixed(0);
            medianVelocityOutputEl.textContent = medianVelocityMps.toFixed(2);
            medianVelocityOutputKmhEl.textContent = mpsToKmh(medianVelocityMps).toFixed(1);
        }

        async function requestPermissionsAndInitSensors() {
            // ... (Permission logic remains the same)
            permissionStatusEl.textContent = "Requesting permissions...";
            try {
                if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                    const motionPerm = await DeviceMotionEvent.requestPermission();
                    if (motionPerm !== 'granted') throw new Error('Motion sensor permission denied.');
                }
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    const orientationPerm = await DeviceOrientationEvent.requestPermission();
                    if (orientationPerm !== 'granted') throw new Error('Orientation sensor permission denied.');
                }
                permissionStatusEl.textContent = "Permissions granted. Initializing sensors...";

                return new Promise((resolve, reject) => {
                    let sensorsOk = { accel: false, orient: false };
                    const checkAllOk = () => { if (sensorsOk.accel && sensorsOk.orient) resolve(true); };
                    const onSensorError = (sensorName, event) => {
                         console.error(`${sensorName} Error:`, event.error);
                         statusEl.textContent = `${sensorName} Error: ${event.error.message}.`;
                         reject(new Error(`${sensorName} failed: ${event.error.message}`));
                    };

                    if ('LinearAccelerationSensor' in window) {
                        linearAccelerationSensor = new LinearAccelerationSensor({ frequency: 60 });
                        linearAccelerationSensor.addEventListener('reading', () => {
                            imuRawAcceleration.x = linearAccelerationSensor.x || 0;
                            imuRawAcceleration.y = linearAccelerationSensor.y || 0;
                            imuRawAcceleration.z = linearAccelerationSensor.z || 0;
                            if (isTracking) processIMUData();
                        });
                        linearAccelerationSensor.addEventListener('error', e => onSensorError('LinearAccelerationSensor', e));
                        linearAccelerationSensor.start();
                        sensorsOk.accel = true;
                    } else { reject(new Error('LinearAccelerationSensor not supported.')); return; }

                    if ('AbsoluteOrientationSensor' in window) {
                        absoluteOrientationSensor = new AbsoluteOrientationSensor({ frequency: 60 });
                        absoluteOrientationSensor.addEventListener('reading', () => {
                            if (absoluteOrientationSensor.quaternion) {
                                imuOrientationQuaternion = [...absoluteOrientationSensor.quaternion];
                            }
                        });
                        absoluteOrientationSensor.addEventListener('error', e => onSensorError('AbsoluteOrientationSensor', e));
                        absoluteOrientationSensor.start();
                        sensorsOk.orient = true;
                    } else { reject(new Error('AbsoluteOrientationSensor not supported.')); return; }
                    checkAllOk();
                });
            } catch (error) {
                permissionStatusEl.textContent = `Error: ${error.message}`;
                statusEl.textContent = "Error: Permissions or sensors unavailable.";
                console.error("Permission or sensor init error:", error);
                return false;
            }
        }

        startTrackingButton.addEventListener('click', async () => {
            if (!isTracking) { // --- STARTING ---
                userPowerParams = { /* ...get params... */
                    totalMass: parseFloat(totalMassInput.value),
                    dragCoefficient: parseFloat(dragCoefficientInput.value),
                    frontalArea: parseFloat(frontalAreaInput.value),
                    rollingResistanceCoefficient: parseFloat(rollingResistanceInput.value),
                    airDensity: parseFloat(airDensityInput.value)
                };
                ACCEL_FILTER_ALPHA = parseFloat(accelFilterAlphaInput.value);
                if (Object.values(userPowerParams).some(isNaN) || isNaN(ACCEL_FILTER_ALPHA) || ACCEL_FILTER_ALPHA <=0 || ACCEL_FILTER_ALPHA >=1) {
                    alert("Please ensure all configuration values are valid numbers and Alpha is between 0.01 and 0.99.");
                    return;
                }

                try {
                    await requestPermissionsAndInitSensors();
                    isTracking = true;
                    startTrackingButton.textContent = "Stop Tracking";
                    startTrackingButton.classList.add("stop");
                    statusEl.textContent = "Tracking...";
                    sessionSummaryEl.style.display = 'none'; // Hide summary

                    imuPositionOffset_window = { x: 0, y: 0, z: 0 };
                    imuVelocity_window = { x: 0, y: 0, z: 0 };
                    filteredWorldAcceleration = { x: 0, y: 0, z: 0 };
                    powerWindowHistory = [];
                    velocityWindowHistory = [];
                    sessionMedianPowerSamples = [];
                    sessionMedianVelocitySamples = [];
                    lastTimestamp_IMU_Processing = performance.now();
                    lastOneSecondCycleTimestamp = performance.now();

                    oneSecondCycleTimer = setInterval(() => {
                        if (!isTracking) return;

                        const now = performance.now();
                        const actualIntervalDuration = (now - lastOneSecondCycleTimestamp) / 1000.0;

                        const displacementCurrentWindow = { ...imuPositionOffset_window };
                        const finalVelocityCurrentWindow = { ...imuVelocity_window };

                        const powerData = calculateCyclingPower({
                            displacement: displacementCurrentWindow,
                            finalVelocity: finalVelocityCurrentWindow,
                            deltaTimeWindow: actualIntervalDuration,
                            userConfig: userPowerParams
                        });

                        powerWindowHistory.push(powerData.power);
                        if (powerWindowHistory.length > MAX_WINDOW_HISTORY_LENGTH) powerWindowHistory.shift();
                        velocityWindowHistory.push(powerData.finalVelocityHorizontal);
                        if (velocityWindowHistory.length > MAX_WINDOW_HISTORY_LENGTH) velocityWindowHistory.shift();

                        const currentMedianPower = calculateMedianOfTopN(powerWindowHistory, MAX_WINDOW_HISTORY_LENGTH, 5);
                        const currentMedianVelocityMps = calculateMedianOfTopN(velocityWindowHistory, MAX_WINDOW_HISTORY_LENGTH, 5);

                        sessionMedianPowerSamples.push(currentMedianPower);
                        sessionMedianVelocitySamples.push(currentMedianVelocityMps);

                        updateUIDisplayCycleEnd(displacementCurrentWindow, finalVelocityCurrentWindow, actualIntervalDuration, powerData, currentMedianPower, currentMedianVelocityMps);

                        imuPositionOffset_window = { x: 0, y: 0, z: 0 };
                        imuVelocity_window = { x: 0, y: 0, z: 0 };
                        lastOneSecondCycleTimestamp = now;

                    }, 1000); // Target 1-second interval

                } catch (error) {
                    statusEl.textContent = "Failed to start sensors: " + error.message;
                    console.error("Sensor start failed:", error);
                    isTracking = false;
                }
            } else { // --- STOPPING ---
                isTracking = false;
                if (linearAccelerationSensor) linearAccelerationSensor.stop();
                if (absoluteOrientationSensor) absoluteOrientationSensor.stop();
                if (oneSecondCycleTimer) clearInterval(oneSecondCycleTimer);
                oneSecondCycleTimer = null;

                statusEl.textContent = "Idle - Tracking Stopped";
                startTrackingButton.textContent = "Start Tracking & Estimating Power";
                startTrackingButton.classList.remove("stop");
                permissionStatusEl.textContent = "";
                lastTimestamp_IMU_Processing = null;

                // Calculate and display session averages
                const avgSessionPower = calculateAverage(sessionMedianPowerSamples);
                const avgSessionVelocityMps = calculateAverage(sessionMedianVelocitySamples);

                avgMedianPowerEl.textContent = avgSessionPower.toFixed(0);
                avgMedianVelocityEl.textContent = avgSessionVelocityMps.toFixed(2);
                avgMedianVelocityKmhEl.textContent = mpsToKmh(avgSessionVelocityMps).toFixed(1);
                sessionSummaryEl.style.display = 'block'; // Show summary

                // Optionally clear instantaneous displays or leave them with last values
                 updateUIDisplayCycleEnd({x:0,y:0,z:0}, {x:0,y:0,z:0}, 0, {power:0, finalVelocityHorizontal:0}, 0, 0);
            }
        });
        // Initial UI state
        updateUIDisplayCycleEnd({x:0,y:0,z:0}, {x:0,y:0,z:0}, 0, {power:0, finalVelocityHorizontal:0}, 0, 0);
    </script>
</body>
</html>
